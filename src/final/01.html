<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="../fx.js"></script>
</head>
<body>
<script>


    function f1(limit, list) {
        let acc = 0;
        for (const a of L.filter((a) => a % 2, list)) {
            const b = a * a;
            acc += b;
            if (--limit == 0) break;
        }
        console.log(acc);
    }
    const iter = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    f1(3, iter)

    function f2(limit, list) {
        let acc = 0;
        for (const a of L.map(a => a * a, L.filter((a) => a % 2, list))) {
            acc += a;
            if (--limit == 0) break;
        }
        console.log(acc);
    }

    f2(3, iter)

    function f3(limit, list) {
        let acc = 0;
        for (const a of L.take(limit, L.map(a => a * a, L.filter((a) => a % 2, iter)))) {
            acc += a;
        }
        console.log(acc);
    }

    f3(3, iter)

    function f4(limit, list) {
        let acc = 0;
        const total = _.reduce((acc, a) => acc + a, acc, L.take(limit, L.map(a => a * a, L.filter((a) => a % 2, list))))
        console.log(total)
    }

    f4(3, iter)

    const obj1 = {
        a: 1,
        b: undefined,
        c: 'CC',
        d: 'DD',
    };

    function query1(obj){
        let query = [];
        for (const key in obj1) {
            if(obj1[key]) {
                query.push(`${key}=${obj1[key]}`)
            }
        }
        return query.join('&');
    }
    // a=1&c=CC&d=DD
    console.clear();
    console.log(query1(obj1))


    function query3(obj){
        return _.reduce(
            (a, b) => `${a}&${b}`,
            _.map(
                ([k, v]) => `${k}=${v}`,
                _.filter(
                    ([k, v]) => v !== undefined,
                    Object.entries(obj)
                )
            )
        )
    }

    console.clear();
    console.log(query3(obj1))

    const split = _.curry((sep, str) => str.split(sep));

    const queryToObject = _.pipe(
        split('&'),
        _.map(split('=')),
        _.map(([k, v]) => ({[k]: v})),
        _.reduce((a, b) => ({...a, ...b}))
    );
    console.log(queryToObject('a=1&c=CC&d=DD'))
    console.log(_.take(1, [1, 2, 3]))

    const a = [ ['a', 1], ['b', 2], ['c', 3] ];
    const b = { a: 1, b: 2, c: 3 };

    const _object = function (iter){
        return _.reduce(Object.assign, L.map(([k, v]) => ({ [k]: v }), iter));
    }

    const obj2 = { a: 1, b: 2, c: 3, d: 4, e: 5 };

    const pick = (keys, iter) => _.go(
        keys,
        L.map(key => [key, iter[key]]),
        L.filter(([k, v]) => v),
        _object
    )
    console.clear();
    console.log(pick(['b', 'c', 'z'], obj2)); // { b: 2, c: 3 }

    const users = [
        { id: 5, name: 'AA', age: 35 },
        { id: 10, name: 'BB', age: 15 },
        { id: 19, name: 'CC', age: 95 },
        { id: 23, name: 'DD', age: 55 },
        { id: 24, name: 'EE', age: 45 },
    ];

    // _indexBy(u => u.id, users);
    // >> { 5: { id: 5, name: 'AA', age: 35 },
    //     10: { id: 10, name: 'BB', age: 15 }, ... }

    const _indexBy = (f, iter) =>
        _.reduce((acc, obj) => Object.assign(acc, { [f(obj)]: obj }), {}, iter);

    console.clear();
    console.log(_indexBy(u => u.id, users));

    const track = [
        { cars: ['철수', '영희', '철희', '영수'] },
        { cars: ['짱구', '맹구', '훈이', '진희'] },
        { cars: ['혁준', '전기', '왁굳', '캘컬'] },
        { cars: ['헐크', '아이언맨'] },
        { cars: [] },
    ];

    console.clear()
    _.go(
        L.range(Infinity),
        L.map(i => track[i]),
        L.map(({cars}) => cars),
        L.map(_.delay(1000)),
        L.takeWhile(({length}) => length >= 4),
        L.flat,
        // _.each(console.log)
    )

    const Impt = {
        payments: {
            1: [
                {imp_id: 11, order_id: 1, amount: 15000},
                {imp_id: 12, order_id: 2, amount: 25000},
                {imp_id: 13, order_id: 3, amount: 10000}
            ],
            2: [
                {imp_id: 14, order_id: 4, amount: 25000},
                {imp_id: 15, order_id: 5, amount: 45000},
                {imp_id: 16, order_id: 6, amount: 15000}
            ],
            3: [
                {imp_id: 17, order_id: 7, amount: 20000},
                {imp_id: 18, order_id: 8, amount: 30000}
            ],
            4: [],
            5: [],
            //...
        },
        getPayments: page => {
            console.log(`http://..?page=${page}`);
            return _.delay(1000 * 1, Impt.payments[page]);
        },
        cancelPayment: imp_id => Promise.resolve(`${imp_id}: 취소완료`)
    };

    const DB = {
        getOrders: ids => _.delay(100, [
            { id: 1 },
            { id: 3 },
            { id: 7 }
        ])
    };

    async function job() {
        const payments = await _.go(
            L.range(1, Infinity),
            L.map(Impt.getPayments),
            L.takeUntil(({ length }) => length < 3),
            _.flat,
            // console.log
        )
        console.log('execute !', payments)

        const order_ids = await _.go(
            payments,
            L.map(({ order_id }) => order_id),
            DB.getOrders,
            _.map(({ id }) => id)
        )
        console.log({order_ids})

        await _.go(
            payments,
            L.reject(({order_id}) => order_ids.includes(order_id)),
            L.map(({imp_id}) => imp_id),
            _.each(Impt.cancelPayment),
        )

    }

    // 5초에 한번만 실행.
    // 5초보다 job 실행이 더 오래걸리면, job이 끝날때까지 대기
    (function recur() {
        Promise.all([
            _.delay(5000, undefined),
            job()
        ]).then(recur);
    })()

</script>
</body>
</html>
